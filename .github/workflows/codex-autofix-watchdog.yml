name: codex-autofix-watchdog

on:
  schedule:
    - cron: "*/2 * * * *"
  workflow_dispatch: {}

permissions:
  contents: read
  actions: write
  pull-requests: read
  issues: write

jobs:
  watchdog:
    runs-on: ubuntu-latest
    steps:
      - name: Cancel stale autofix runs and retry once
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CODEX_REVIEW_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const queuedLimitMs = 3 * 60 * 1000;
            const inProgressLimitMs = 10 * 60 * 1000;
            const now = Date.now();
            const runTitleRe = /\bpr=(\d+)\s+sha=([0-9a-f]{7,40})\s+attempt=(\d+)\b/i;

            const listRuns = async (status) => {
              return await github.paginate(github.rest.actions.listWorkflowRuns, {
                owner,
                repo,
                workflow_id: 'codex-autofix-selfhosted.yml',
                status,
                per_page: 100,
              });
            };

            const queuedRuns = await listRuns('queued');
            const inProgressRuns = await listRuns('in_progress');
            const staleRuns = [];

            const maybeAddStale = (run, status) => {
              const display = String(run.display_title || run.name || '');
              const m = display.match(runTitleRe);
              if (!m) {
                core.info(`Skip run ${run.id}: cannot parse run title "${display}".`);
                return;
              }
              const prNumber = Number(m[1]);
              const sha = String(m[2]).toLowerCase();
              const attempt = Number(m[3]);

              const createdMs = Date.parse(String(run.created_at || ''));
              const startedMs = Date.parse(String(run.run_started_at || run.updated_at || run.created_at || ''));
              const ageMs = status === 'queued' ? (now - createdMs) : (now - startedMs);
              const limitMs = status === 'queued' ? queuedLimitMs : inProgressLimitMs;
              if (!Number.isFinite(ageMs) || ageMs <= limitMs) {
                return;
              }

              staleRuns.push({
                runId: run.id,
                runUrl: run.html_url,
                status,
                ageMs,
                prNumber,
                sha,
                attempt,
              });
            };

            queuedRuns.forEach(run => maybeAddStale(run, 'queued'));
            inProgressRuns.forEach(run => maybeAddStale(run, 'in_progress'));

            if (staleRuns.length === 0) {
              core.info('No stale codex-autofix-selfhosted runs found.');
              return;
            }

            for (const stale of staleRuns) {
              core.info(
                `Handling stale run id=${stale.runId} pr=${stale.prNumber} sha=${stale.sha} status=${stale.status} age_ms=${stale.ageMs}`
              );

              try {
                await github.rest.actions.cancelWorkflowRun({
                  owner,
                  repo,
                  run_id: stale.runId,
                });
              } catch (err) {
                core.warning(`Failed to cancel stale run ${stale.runId}: ${err}`);
                continue;
              }

              const issueComments = await github.paginate(
                github.rest.issues.listComments,
                { owner, repo, issue_number: stale.prNumber, per_page: 100 }
              );
              const retryMarker = `<!-- codex-autofix:watchdog-retry sha=${stale.sha} attempt=2 -->`;

              if (stale.attempt >= 2) {
                const noRetryMarker =
                  `<!-- codex-autofix:watchdog-stale sha=${stale.sha} attempt=${stale.attempt} action=cancelled-no-retry -->\n` +
                  `Watchdog cancelled stale autofix run without retry.\n\n` +
                  `pr=#${stale.prNumber}\n` +
                  `sha=${stale.sha}\n` +
                  `attempt=${stale.attempt}\n` +
                  `status=${stale.status}\n` +
                  `age_ms=${stale.ageMs}\n` +
                  `run=${stale.runUrl}`;
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: stale.prNumber,
                  body: noRetryMarker,
                });
                continue;
              }

              const alreadyRetried = issueComments.some(c => String(c.body || '').includes(retryMarker));
              if (alreadyRetried) {
                core.info(`Skip watchdog retry for pr=${stale.prNumber} sha=${stale.sha}: marker already exists.`);
                continue;
              }

              const retryComment = await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: stale.prNumber,
                body:
                  `${retryMarker}\n` +
                  `Watchdog cancelled stale autofix run and queued a single retry.\n\n` +
                  `pr=#${stale.prNumber}\n` +
                  `sha=${stale.sha}\n` +
                  `status=${stale.status}\n` +
                  `age_ms=${stale.ageMs}\n` +
                  `cancelled_run=${stale.runUrl}\n` +
                  `source=watchdog-stale-run`,
              });
              const retryCommentId = retryComment?.data?.id || null;

              let batchDispatched = false;
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner,
                  repo,
                  workflow_id: 'codex-autofix-dispatch-batched.yml',
                  ref: 'main',
                  inputs: {
                    pr_number: String(stale.prNumber),
                    repo: `${owner}/${repo}`,
                    sha: stale.sha,
                    source: 'watchdog-stale-run',
                    attempt: '2',
                    batch_window_seconds: '0',
                  },
                });
                batchDispatched = true;
              } catch (batchErr) {
                core.warning(`Watchdog batch dispatch failed for pr=${stale.prNumber} sha=${stale.sha}: ${batchErr}`);
              }

              if (batchDispatched) {
                continue;
              }

              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner,
                  repo,
                  workflow_id: 'codex-autofix-selfhosted.yml',
                  ref: 'main',
                  inputs: {
                    pr_number: String(stale.prNumber),
                    repo: `${owner}/${repo}`,
                    target_sha: stale.sha,
                    attempt: '2',
                    source: 'watchdog-stale-run',
                  },
                });
              } catch (directErr) {
                core.warning(
                  `Watchdog direct fallback dispatch failed for pr=${stale.prNumber} sha=${stale.sha}: ${directErr}`
                );
                if (retryCommentId) {
                  try {
                    await github.rest.issues.deleteComment({
                      owner,
                      repo,
                      comment_id: retryCommentId,
                    });
                  } catch (deleteErr) {
                    core.warning(
                      `Watchdog retry marker rollback failed for comment=${retryCommentId}: ${deleteErr}`
                    );
                  }
                }
              }
            }
